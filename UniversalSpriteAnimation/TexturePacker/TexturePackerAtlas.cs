using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Xml.Serialization;

namespace Unisa {
    /// <summary> Contains information about a texture atlas exported from TexturePacker. </summary>
    [XmlType(TypeName = "TextureAtlas")]
    public class TexturePackerAtlas {
        private static readonly char[] _numbers = "0123456789".ToCharArray();

        /// <summary> Initializes a new instance of the <see cref="TexturePackerAtlas" /> class. </summary>
        public TexturePackerAtlas() {
            Sprites = new List<TexturePackerSprite>();
        }

        /// <summary> Gets or sets the path to the texture relative to the data file location. </summary>
        [XmlAttribute("imagePath")]
        public string ImagePath { get; set; }

        /// <summary> Texture's width. </summary>
        [XmlAttribute("width")]
        public int Width { get; set; }

        /// <summary> Texture's height. </summary>
        [XmlAttribute("height")]
        public int Height { get; set; }

        /// <summary> Sprites contained in this atlas. </summary>
        [XmlElement("sprite", Type = typeof(TexturePackerSprite))]
        public List<TexturePackerSprite> Sprites { get; set; }

        /// <summary>
        ///     Creates an animation from the current atlas, collecting sprites into animation sequences
        ///     by their name. Sprites with names distinguished by end number only (like "walking 1", "walking 2",
        ///     "walking 3"...) will be gathered into the same sequence.
        /// </summary>
        /// <param name="animationCreator">Provides concrete type constructor for animation.</param>
        /// <param name="sequenceCreator">Provides concrete type constructor for animation sequence.</param>
        /// <param name="frameCreator">Provides concrete type constructor for animation frame.</param>
        /// <returns> Created animation. </returns>
        public IAnimation CreateAnimation(Func<IAnimation> animationCreator = null,
            Func<IAnimationSequence> sequenceCreator = null, Func<IAnimationFrame> frameCreator = null) {
            if (animationCreator == null) { animationCreator = () => new Animation(); }

            var result = animationCreator();
            result.TextureId = ImagePath;

            var sequenceData = GetSequenceData();
            var sequences = CreateSequences(sequenceData, sequenceCreator, frameCreator);
            foreach (var sequence in sequences) { result.Sequences.Add(sequence); }

            return result;
        }

        /// <summary> Loads the generic XML generated by TexturePacker. </summary>
        /// <param name="atlasDataStream">The XML file stream describing a texture atlas.</param>
        /// <returns> Parsed texture atlas data. </returns>
        public static TexturePackerAtlas Load(Stream atlasDataStream) {
            var xmlSerializer = new XmlSerializer(typeof(TexturePackerAtlas));
            return (TexturePackerAtlas) xmlSerializer.Deserialize(atlasDataStream);
        }

        /// <summary> Gets all sprites which name contains the specified string. </summary>
        /// <param name="namePart">The string to look for in sprite's name.</param>
        /// <returns> Found sprites. </returns>
        public IEnumerable<TexturePackerSprite> FilterByNamePart(string namePart) {
            return Sprites.Where(sprite => sprite.Name != null && sprite.Name.Contains(namePart));
        }

        /// <summary>
        ///     Collects sprites into sequences unified by name. Sprites with names like "walking east 1",
        ///     "walking east 2", "walking east 3" will be gathered into same sequence.
        /// </summary>
        /// <returns> List of sprites corresponding to a single sequence. </returns>
        [Pure]
        private Dictionary<string, List<TexturePackerSprite>> GetSequenceData() {
            var sequencesData = new Dictionary<string, List<TexturePackerSprite>>();
            foreach (var sprite in Sprites) {
                string name = sprite.Name;
                int fileExtPos = name.LastIndexOf(".", StringComparison.Ordinal);
                if (fileExtPos >= 0) { name = name.Substring(0, fileExtPos); }

                if (!EndsWithDigit(name)) {
                    AddToValues(sequencesData, name, sprite);
                } else {
                    name = name.TrimEnd(_numbers).TrimEnd();
                    AddToValues(sequencesData, name, sprite);
                }
            }

            return sequencesData;
        }

        private static IEnumerable<IAnimationSequence> CreateSequences(
            Dictionary<string, List<TexturePackerSprite>> sequenceData, Func<IAnimationSequence> seqCreator = null,
            Func<IAnimationFrame> frameCreator = null) {
            Contract.Requires(sequenceData != null);

            if (frameCreator == null) { frameCreator = () => new AnimationFrame(); }
            if (seqCreator == null) { seqCreator = () => new AnimationSequence(); }

            AnimationFrameMaker frameMaker = source => {
                var frame = frameCreator();
                frame.Source = source;
                return frame;
            };

            AnimationSequenceMaker sequenceMaker = (name, frames) => {
                var seq = seqCreator();
                seq.Name = name;
                seq.Frames.AddRange(frames);
                return seq;
            };

            return from kvp in sequenceData
                let name = kvp.Key
                let frames = kvp.Value.OrderBy(sprite => sprite.Name).Select(
                    sprite => frameMaker(sprite.Source))
                select sequenceMaker(name, frames);
        }

        /// <summary> Checks whether the specified string ends with a digit. </summary>
        /// <param name="target">The string to check.</param>
        /// <returns>true if the given string ends with a digit; false otherwise.</returns>
        [Pure]
        private static bool EndsWithDigit(string target) {
#if LEGACY
            return !String.IsNullOrEmpty(target) && target.Substring(target.Length - 1).Cast<char>().Any(Char.IsDigit);
#else
            return !String.IsNullOrEmpty(target) && target.Substring(target.Length - 1).Any(Char.IsDigit);
#endif
        }

        /// <summary>
        ///     Adds the specified value to the list of the values held under the specified key.
        ///     List will be created if it does not exits.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="target">The dictionary to add value into.</param>
        /// <param name="key">The key used for a list of values.</param>
        /// <param name="toAdd">The value to add to a list of values.</param>
        private static void AddToValues<TKey, TValue>(IDictionary<TKey, List<TValue>> target, TKey key, TValue toAdd) {
            Contract.Requires(target != null);
            Contract.Requires(!ReferenceEquals(key, null));

            List<TValue> existing;
            if (!target.TryGetValue(key, out existing)) {
                existing = new List<TValue>();
                target.Add(key, existing);
            }

            existing.Add(toAdd);
        }

        private delegate IAnimationSequence AnimationSequenceMaker(string name, IEnumerable<IAnimationFrame> frames);

        private delegate IAnimationFrame AnimationFrameMaker(TextureRegion source);
    }
}