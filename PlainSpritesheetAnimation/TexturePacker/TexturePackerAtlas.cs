using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Serialization;

namespace PlainSpritesheetAnimation
{
    /// <summary> Contains information about a texture atlas exported from TexturePacker. </summary>
    [XmlType(TypeName = "TextureAtlas")]
    public class TexturePackerAtlas
    {
        private static readonly char[] _Numbers = "0123456789".ToCharArray();

        /// <summary> Initializes a new instance of the <see cref="TexturePackerAtlas" /> class. </summary>
        public TexturePackerAtlas()
        {
            Sprites = new List<TexturePackerSprite>();
        }

        /// <summary> Gets or sets the path to the texture relative to the data file location. </summary>
        [XmlAttribute("imagePath")]
        public string ImagePath { get; set; }

        /// <summary> Texture's width. </summary>
        [XmlAttribute("width")]
        public int Width { get; set; }

        /// <summary> Texture's height. </summary>
        [XmlAttribute("height")]
        public int Height { get; set; }

        /// <summary> Sprites contained in this atlas. </summary>
        [XmlElement("sprite", Type = typeof(TexturePackerSprite))]
        public List<TexturePackerSprite> Sprites { get; set; }

        /// <summary>
        ///     Creates an animation from the current atlas, collecting sprites into animation sequences
        ///     by their name. Sprites with names distinguished by end number only (like "walking 1", "walking 2",
        ///     "walking 3"...) will be gathered into the same sequence.
        /// </summary>
        /// <param name="sequenceCreator">Provides concrete type constructor for animation sequence.</param>
        /// <param name="frameCreator">Provides concrete type constructor for animation frame.</param>
        /// <returns> Created animation. </returns>
        public IEnumerable<IAnimationSequence> CreateAnimationSequences(
            Func<IAnimationSequence> sequenceCreator = null, Func<IAnimationFrame> frameCreator = null)
        {
            var sequenceData = GetSequenceData();
            var sequences = CreateSequences(sequenceData, sequenceCreator, frameCreator);
            foreach (var sequence in sequences) {
                sequence.TextureId = ImagePath;
                yield return sequence;
            }
        }

        /// <summary> Loads the generic XML generated by TexturePacker. </summary>
        /// <param name="atlasDataStream">The XML file stream describing a texture atlas.</param>
        /// <returns> Parsed texture atlas data. </returns>
        public static TexturePackerAtlas Load(Stream atlasDataStream)
        {
            var xmlSerializer = new XmlSerializer(typeof(TexturePackerAtlas));
            return (TexturePackerAtlas)xmlSerializer.Deserialize(atlasDataStream);
        }

        /// <summary> Gets all sprites which name contains the specified string. </summary>
        /// <param name="namePart">The string to look for in sprite's name.</param>
        /// <returns> Found sprites. </returns>
        public IEnumerable<TexturePackerSprite> FilterByNamePart(string namePart)
        {
            return (Sprites != null)
                ? Sprites.Where(sprite => sprite.Name != null && sprite.Name.Contains(namePart))
                : Enumerable.Empty<TexturePackerSprite>();
        }

        /// <summary>
        ///     Collects sprites into sequences unified by name. Sprites with names like "walking east 1",
        ///     "walking east 2", "walking east 3" will be gathered into same sequence.
        /// </summary>
        /// <returns> List of sprites corresponding to a single sequence. </returns>
        private Dictionary<string, List<TexturePackerSprite>> GetSequenceData()
        {
            var sequencesData = new Dictionary<string, List<TexturePackerSprite>>();
            if (Sprites == null) {
                return sequencesData;
            }

            foreach (var sprite in Sprites) {
                string name = sprite.Name;
                int fileExtPos = name.LastIndexOf(".", StringComparison.Ordinal);
                if (fileExtPos >= 0) {
                    name = name.Substring(0, fileExtPos);
                }

                if (!EndsWithDigit(name)) {
                    AddToValues(sequencesData, name, sprite);
                }
                else {
                    name = name.TrimEnd(_Numbers).TrimEnd();
                    AddToValues(sequencesData, name, sprite);
                }
            }

            return sequencesData;
        }

        private static IEnumerable<IAnimationSequence> CreateSequences(
            Dictionary<string, List<TexturePackerSprite>> sequenceData, Func<IAnimationSequence> seqCreator = null,
            Func<IAnimationFrame> frameCreator = null)
        {
            if (sequenceData == null) {
                throw new ArgumentNullException(nameof(sequenceData));
            }

            if (frameCreator == null) {
                frameCreator = () => new AnimationFrame();
            }
            if (seqCreator == null) {
                seqCreator = () => new AnimationSequence();
            }

            AnimationFrameMaker frameMaker = source => {
                var frame = frameCreator();
                frame.Source = source;
                return frame;
            };

            AnimationSequenceMaker sequenceMaker = (name, frames) => {
                var seq = seqCreator();
                seq.Name = name;
                seq.Frames.AddRange(frames);
                return seq;
            };

            return from kvp in sequenceData
                   let name = kvp.Key
                   let frames = kvp.Value.OrderBy(sprite => sprite.Name).Select(
                                       sprite => frameMaker(sprite.Source))
                   select sequenceMaker(name, frames);
        }

        /// <summary> Checks whether the specified string ends with a digit. </summary>
        /// <param name="target">The string to check.</param>
        /// <returns>true if the given string ends with a digit; false otherwise.</returns>
        private static bool EndsWithDigit(string target)
        {
#if LEGACY
            return !string.IsNullOrEmpty(target) && target.Substring(target.Length - 1).Cast<char>().Any(char.IsDigit);
#else
            return !string.IsNullOrEmpty(target) && target.Substring(target.Length - 1).Any(char.IsDigit);
#endif
        }

        /// <summary>
        ///     Adds the specified value to the list of the values held under the specified key.
        ///     List will be created if it does not exits.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="target">The dictionary to add value into.</param>
        /// <param name="key">The key used for a list of values.</param>
        /// <param name="toAdd">The value to add to a list of values.</param>
        private static void AddToValues<TKey, TValue>(IDictionary<TKey, List<TValue>> target, TKey key, TValue toAdd)
        {
            if (target == null) {
                throw new ArgumentNullException(nameof(target));
            }
            if (ReferenceEquals(key, null)) {
                throw new ArgumentNullException(nameof(key));
            }

            List<TValue> existing;
            if (!target.TryGetValue(key, out existing)) {
                existing = new List<TValue>();
                target.Add(key, existing);
            }

            existing.Add(toAdd);
        }

        private delegate IAnimationSequence AnimationSequenceMaker(string name, IEnumerable<IAnimationFrame> frames);

        private delegate IAnimationFrame AnimationFrameMaker(TextureRegion source);
    }
}